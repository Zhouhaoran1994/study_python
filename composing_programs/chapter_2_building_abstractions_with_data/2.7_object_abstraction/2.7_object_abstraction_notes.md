# Object Abstraction (对象的抽象机制)

## String Conversion (字符串转换)

为了帮助人们更好理解对象，我们可以规范化对象的字符串表达形式

利用repr和eval可以把对象和字符串互相转换

> repr(object) -> string
>
> Return the canonical string representation of the object.
>
> For most object types, eval(repr(object)) == object.

~~~
>>> from datetime import date
>>> tues = date(2011, 9, 12)
>>> repr(tues)
'datetime.date(2011, 9, 12)'
>>> str(tues)
'2011-09-12'
>>> tues.__repr__()
'datetime.date(2011, 9, 12)'
>>> tues.__str__()
'2011-09-12'
~~~

## Special Methods (对象的特殊方法)

### True and false values (布尔值)

~~~
Account.__bool__ = lambda self: self.balance != 0
>>> if not Account('Jack'):
        print('Jack has nothing')
Jack has nothing
~~~

### Sequence operations (列表式操作)

~~~
Account.__len__ = lamda self: self.balance
Account.__getitem__ = lambda self, item: self.balance if item == 1
~~~

### Callable objects (可调用对象)

只要设置__call__方法，类也可以直接调用，就像high-order functions一样

这样数据和方法之间的界限就更模糊了

> Here, the Adder class behaves like the make_adder higher-order function, and the add_three_obj object behaves like the
> add_three function. We have further blurred the line between data and functions.

~~~
>>> def make_adder(n):
        def adder(k):
            return n + k
        return adder
>>> add_three = make_adder(3)
>>> add_three(4)
7

>>> class Adder(object):
        def __init__(self, n):
            self.n = n
        def __call__(self, k):
            return self.n + k
>>> add_three_obj = Adder(3)
>>> add_three_obj(4)
7
~~~

### Arithmetic

可以通过设置特殊方法，定义对象之间的运算

[method names for operators](https://docs.python.org/3/reference/datamodel.html#special-method-names)

~~~python
class Account:
    def __init__(self, holder_name, balance=0):
        self.holder_name = holder_name
        self.balance = balance

    def __add__(self, other):
        return self.balance + other.balance


jack = Account('Jack', 25)
bill = Account('Bill', 50)
print(jack + bill)  # 75
~~~

## Multiple Representations (对象的多种表达定义)

复数常用的有两种表达形式，一种是直角坐标，另一种是极坐标

直角坐标: c = a + bi，a为实部(real)，b为虚部(imaginary)

极坐标: c = r * cos theta + r * i * sin theta ，r为强度(magnitude)，角度theta为相位(phase/angle)

[参考资料：复数的几种表示形式](https://mengqi92.github.io/2015/10/06/complex/)

下面就来实现复数的不同形式表达

首先不急着创建ComplexNumber，而是创建Number，目的是作为不同number的父类

> A Complex number is a Number, and numbers can be added or multiplied together. How numbers can be added or multiplied
> is abstracted by the method names add and mul.
>
> The purpose of Number is not to be instantiated directly, but instead to serve as a superclass of various specific
> number classes.

~~~python
class Number:
    def __add__(self, other):
        return self.add(other)  # 让子类自己实现具体的add方法，下同

    def __mul__(self, other):
        return self.mul(other)


class Complex(Number):
    def add(self, other):
        # 注意这个Complex类依然没有__init__，因为根据开头的公式定义，不同的表达里有不同的变量，把变量的初始化交给具体的子类
        return ComplexRI(self.real + other.real, self.imag + other.imag)

    def mul(self, other):
        return ComplexMA(self.magnitude * other.magnitude, self.angle + other.angle)


from math import atan2, sin, cos, pi


class ComplexRI(Complex):
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    # 为什么要实现这两个property装饰的方法？
    # 因为事实上，这两种表达方式可以互相转换
    # 作者可能想传达的是，即使现在没有这样的需求，难保未来会有
    @property
    def magnitude(self):
        return (self.real ** 2 + self.imag ** 2) ** 0.5

    @property
    def angle(self):
        return atan2(self.imag, self.real)

    def __repr__(self):
        return f"ComplexRI({self.real}, {self.imag})"




class ComplexMA(Complex):
    def __init__(self, magnitude, angle):
        self.magnitude = magnitude
        self.angle = angle

    @property
    def real(self):
        return self.magnitude * cos(self.angle)

    @property
    def imag(self):
        return self.magnitude * sin(self.angle)

    def __repr__(self):
        return f"ComplexMA({self.magnitude}, {self.angle / pi} * pi)"

if __name__ == '__main__':
    ma = ComplexMA(2, pi/2)
    print(ma)
    print(ma.angle)
    
    result = ComplexRI(1, 2) + ComplexMA(2, pi/2)
    print(result)
~~~