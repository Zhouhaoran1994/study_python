# Mutable Data (可变数据)

## The Object Metaphor (什么是Object？)

主要学单词
1. object (对象)
2. instance (实例)
3. attribute (属性)
4. method (方法)

## Sequence Objects (列表对象)

先看下面的代码

~~~python
a = 1
b = a
b += 1
print(a, b) # 1 2

c = [1, 2]
d = a
d += [3]
print(c, d) #[1, 2, 3] [1, 2, 3]
~~~

这说明列表是可变数据，c和d指向了同一个内存地址

下面这两张图很形象地表达了，可变,不可变数据和内存的关系

[原文地址](https://blog.csdn.net/gzhzzaa/article/details/122645611)

![Immutable Data](https://thumbnail1.baidupcs.com/thumbnail/a77411069t6cb6a438aab7ed70ce93af?fid=2889647277-250528-270627586913279&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-A84XFQwqWgiwjzv4LInKeL00qXk%3d&expires=8h&chkbd=0&chkv=0&dp-logid=9102503786639744399&dp-callid=0&time=1670580000&size=c1920_u1080&quality=90&vuk=2889647277&ft=image&autopolicy=1)

![Mutable Data](https://thumbnail1.baidupcs.com/thumbnail/e399287f3l2c226206e12f743ab6835a?fid=2889647277-250528-871874367366769&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-nRIv0ier2r1gW%2f2IKkXBDtJbarc%3d&expires=8h&chkbd=0&chkv=0&dp-logid=9102503786639744399&dp-callid=0&time=1670580000&size=c1920_u1080&quality=90&vuk=2889647277&ft=image&autopolicy=1)

可以用is和is not来判断两个对象是否"相同"

注意is对比的是内存地址，相当于id(a) == id(b)，而==对比的仅仅是内容(值)

~~~python
nested = [1, 2]
suits = ['heart', 'diamond', 'spade', 'club']
nested[0] = suits

print(suits is nested[0]) # True
print(suits is ['heart', 'diamond', 'spade', 'club']) # False
print(suits == ['heart', 'diamond', 'spade', 'club']) # True
~~~

## Dictionaries (字典)

字典也有生成式

~~~
>>> {x: x*x for x in range(3,6)}
{3: 9, 4: 16, 5: 25}
~~~

## Local State (本地状态)

> Lists and dictionaries have local state
> 
> Functions can also have local state
> 
> The word "state" implies an evolving process in which that state may change.

这三句话怎么理解？来看这个例子：

比如现在要实现一个银行账户取钱功能，每取一次钱，余额就会减少，直到全部取光则提示余额不足

我们希望见到的画面是这样的
~~~
>>> withdraw(25)
75
>>> withdraw(25)
50
>>> withdraw(60)
'Insufficient funds'
>>> withdraw(15)
35
~~~

可以看见，调用了withdraw(25)两次，但返回值不一样，所以这不是一个写死的函数(non-pure)

而是每次调用后，会有个因子(side effect)影响下一个返回值

这个因子的作用是，让withdraw对自身作用域外的地方，让变量指向了新内存地址(name-value binding)

要取钱，先充钱，还需要一个充钱的功能

~~~
withdraw = make_withdraw(100)
~~~

可以猜到make_withdraw又是1.6提过的高阶函数(high-order functions)

第一反应会这样写

~~~python
def make_withdraw(balance):
        def withdraw(amount):
            if amount > balance:
                return 'Insufficient funds'
            balance = balance - amount
            return balance
        return withdraw
~~~

但这样会报错，提示

> "UnboundLocalError: local variable 'balance' referenced before assignment"

意思是balance在声明之前就被引用了

仔细看withdraw函数，它确实没有初始化balance，但它的父环境make_withdraw有

给balance加一个nonlocal就可以解决问题

~~~python
def make_withdraw(balance):
        """Return a withdraw function that draws down balance with each call."""
        def withdraw(amount):
            nonlocal balance                 # Declare the name "balance" nonlocal
            if amount > balance:
                return 'Insufficient funds'
            balance = balance - amount       # Re-bind the existing balance name
            return balance
        return withdraw
~~~

nonlocal会使python到balance第一次初始化的地方(first frame)进行引用

>The nonlocal statement declares that whenever we change the binding of the name balance, the binding is changed in the first frame in which balance is already bound

假如没有nonlocal，python只会在函数内(current environment/local frame)进行引用
> Recall that without the nonlocal statement, an assignment statement would always bind a name in the first frame of the current environment.

[扩展阅读：Closure (闭包)](https://www.liaoxuefeng.com/wiki/1016959663602400/1017434209254976)

### Python Particulars (Python特性)

回头仔细看这个报错

> "UnboundLocalError: local variable 'balance' referenced before assignment"

完整的traceback是

~~~
Traceback (most recent call last):
  File "C:\Haoran\Study\study_python\composing_programs\chapter_2_building_abstractions_with_data\2.4_mutable_data\2.4_mutable_data.py", line 34, in <module>
    wd(5)
  File "C:\Haoran\Study\study_python\composing_programs\chapter_2_building_abstractions_with_data\2.4_mutable_data\2.4_mutable_data.py", line 26, in withdraw
    if amount > balance:
UnboundLocalError: local variable 'balance' referenced before assignment
~~~

其实python在if amount > balance就发现错误了，还没有去到balance = balance - amount

这是python的预计算特性(pre-computing)

当然不知道有什么用，纯当留个印象

## The Benefits of Non-Local Assignment (nonlocal的好处)